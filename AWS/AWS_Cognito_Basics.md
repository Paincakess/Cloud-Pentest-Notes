# AWS Cognito

AWS Cognito is responsible for providing **authentication**, **authorization**, and **user management** for web and mobile applications. Users can sign in using their username or password, or even third party sign in options such as Google, Apple, Facebook, etc.
There are two main components of Amazon Cognito, which are,

- **User Pools**, They are user directories which provides sign-in and sign-up options for the application users.
- **Identity Pools**, They enable you to grant the users access to other AWS Services.

# User Pools

## Background

The **User Pool** is basically a user directory used by AWS Cognito. Users can sign in to the web application or mobile application through Cognito, or federate through a third party identity providers. Whether they are directly signed in or through any third party identity provider, all the members of the user pool have a directory profile that you can access through an SDK.

Functionalities of User Pools,

- Sign-up and sign-in services.
- A built-in, customizable web UI to sign in users.
- Social sign-in with Facebook, Google, Login with Amazon, and Sign in with Apple, and through SAML and OIDC identity providers from your user pools.
- User profile and directory management.
- Security features such as multi-factor authentication (MFA), checks for compromised credentials, account takeover protection, and phone and email verification.
- Customized workflows and user migration through AWS Lambda triggers.

## User Registration

Registering new users to the User Pool is set by default.

- `aws cognito-idp sign-up --client-id <client-id> --username <username> --password <password> --region <region> --no-sign-request`

You might encounter an error indicating you that you need to provide more details of the user.

```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```

For that we can provide the needed details with a JSON such as:

```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```

This functionality can also be abused to enumerate existing users or even client ID.
This is the error message when a user already exists with that name.

```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```

This is the error message if the client ID doesn't exist.

```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```

## Verifying Registration

AWS Cognito allows to verify the new user by verifying either email address or mobile number. Just use one from both which you have control to, there you will receive the code to verify the newly created user account using the following command,

- `cognito-idp confirm-sign-up --client-id <client_id> --username <username> --confirmation-code <conf_code> --no-sign-request --region <region>`

*If the existing email address or phone number is accepted, but the account cannot be verified.*

## Authentication Methods

There are different types of authentication methods which can be used, also if you have a username and password there are also different methods supported to login. After user is authenticated in the pool, three types of tokens are given, which are, **ID Token**, **Access Token**, and **Refresh Token**.

- **ID Token:** The ID Token contains the attributes of the user, which are the claims about the identity of the authenticated user. They are also used to authenticate users to different AWS resources or server applicaitons. Although its necessary to verify the signature of the ID token to maintain trust and any claims inside the ID token if you use it in external applications.
- **Access Token:** It will contain claims about the authenticated user, a list of user groups, and a list of scopes. The main purpose of the access token is to **authorize API operations** in the context of the user in the user pool. For example, the access token can be used to grant permissions to the user to modify their user attributes.
- **Refresh Tokens:** They are used to get fresh new pair of ID tokens and Access Token for the users.By default, the refresh token expires 30 days (whic can be adjusted as needed) after the application user signs into the user pool.

### ADMIN\_NO\_SRP\_AUTH | ADMIN\_USER\_PASSWORD\_AUTH

**Server side authentication flow**:

- The server side application calls the `AdminInitiateAuth` API Operation. This operation requires AWS credentials with required permission which includes `cognito-idp:AdminInitiateAuth` and `cognito-idp:AdminRespondToAuthChallenge`. This operation returns the required authentication parameters.
- After the server side application has the authentication parameters, it will call `AdminRespondToAuthChallenge` API operation, which only succeeds when AWS credentials is provided.

*In order to be able to login with this method that application must allow to login with `ALLOW_ADMIN_USER_PASSWORD_AUTH`. This method is **NOT** enabled by default*

To login, we will require **user pool id**, **client id**, **username**, **password**, **client secret** (if set in the application)

```
aws cognito-idp admin-initiate-auth \
    --client-id <client-id> \
    --auth-flow ADMIN_USER_PASSWORD_AUTH \
    --region <region> \
    --auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
    --user-pool-id "<pool-id>"`
```

To Login with python, use the following code,

```
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
    key = bytes(client_secret, 'utf-8')
    message = bytes(f'{username}{client_id}', 'utf-8')
    return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
    try:
        return boto_client.admin_initiate_auth(
            UserPoolId=user_pool_id,
            ClientId=client_id,
            AuthFlow='ADMIN_USER_PASSWORD_AUTH',
            AuthParameters={
                'USERNAME': username_or_alias,
                'PASSWORD': password,
                'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
            }
        )
    except botocore.exceptions.ClientError as e:
        return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```

### USER\_PASSWORD\_AUTH

This method is traditional user & password authentication flow. It's recommended to migrate a traditional authentication method to Cognito and recommended to then disable it and use then `ALLOW_USER_SRP_AUTH` method instead, which will not send the password over the network.
The main difference with the previous auth method inside the code is that you will not require **user pool id** and that you don't need extra permissions in the Cognito User Pool.
*This method is also not enabled by default*

- `aws cognito-idp initiate-auth --client-id <client-id> --auth-flow USER_PASSWORD_AUTH --region <region> --auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'`

### USER\_SRP\_AUTH

This process is similar to `USER_PASSWORD_AUTH` but instead of sending the password through the network to login a challenge authentication is performed. You will need following code to run,

```
from warrant.aws_srp import AWSSRP
import os

USERNAME='<username>'
PASSWORD='<password>'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID, 
    client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```

### REFRESH\_TOKEN\_AUTH | REFRESH_TOKEN

This method is always valid and it cannot be disabled, but you will need to have valid refresh token.

```
aws cognito-idp initiate-auth \
    --client-id 3ig6h5gjm56p1ljls1prq2miut \
    --auth-flow REFRESH_TOKEN_AUTH \
    --region <region> \
    --auth-parameters 'REFRESH_TOKEN=<token>'
```

### CUSTOM_AUTH

For this authentication methodology, lambda function will be executed.

## Privilege Escalation

### Modifying User Attributes

Users can modify the value of their attributes, using command like this,

- `aws cognito-idp update-user-attributes --region <region> --no-sign-request --user-attributes Name=address,Value=street --access-token <access token>`
    In some cases, the users might have custom attribute set to them (such as `isAdmin`), and by default user can change the values of their own attributes which might let the user to escalate their privileges changing the value of their attributes themselves.

### Email/Username Modification

One of the thing to remember is that, you won't be able to login with email or phone number unless its verified. Although you will be able to login with username. Also, even if the email was modified and not verified it will be displayed in the ID Token within the email field and the filed email verified will be false, but if the application isn't verifying that, attacker can impersonate other users.
To confirm the email, you can use the command like this using the verification code sent in the given email address.

- `aws cognito-idp verify-user-attribute --access-token <access_token> --attribute-name email --code <code> --region <region> --no-sign-request`
    *Change the `email` to `phone_number` if you want to verify the phone number.*

### Recover/Change Password

It is possible to recover password with username, email or phone number, which you should have access to as the code will be sent there.

- `aws cognito-idp forgot-password --client-id <client_id> --username <username/email/phone> --region <region>`

*Another thing to note that, the response of the server for this request is always positieve, so username enumeration is not possible in this case*

After getting the code, you can use command like this

- `aws cognito-idp confirm-forgot-password --client-id <client_id> --username <username> --confirmation-code <conf_code> --password <pwd> --region <region>`

To directly change password without code, you will need to know previous password of the user.

- `aws cognito-idp change-password --previous-password <value> --proposed-password <value> --access-token <value>`

## Potential Attacks

*Source codes of applications can contain the user ID pools and client application ID, which are needed for user to login to a Cognito User Pool.*

- **Registration:** By default a user can register himself, so attacker could also create a user for himself.
- **User Enumeration:** The registration functionality can be used to find usernames that already exists. This information can be useful for the attacker to perform the brute force attacks.
- **Login Brute Force:** From the all those authentication methodology, attacker can try to brute force them to find valid credentials.

# Identity Pools

## Basic Information

Users can obtain **temporary credentials to access AWS services**, with an identity pool, which also supports anonymous guest users. The following identity providers can also be used to authenticate users for identity pools:

- Amazon Cognito User Pools
- Social sign-in with Google, Facebook, Apple and Amazon
- OpenID Connect (OIDC) providers
- SAML identity providers
- Developer authenticated identities

## Accessing IAM Roles

### Unauthenticated

An attacker only requires knowledge of the Identity Pool ID in order to obtain AWS credentials for a Cognito app as an unauthenticated user. This ID must be included in the code of the web or mobile application for it to be used. The Format of the ID looks like this `eu-west-1:098e5341-8364-038d-16de-1865e435da3b` which is not bruteforceable.
If there is Identity pools ID bruteforced and it allows unauthenticated users, AWS credentials can be enumerated, using the following command.

- `aws cognito-identity get-id --identity-pool-id <identity_pool_id> --no-sign`
- `aws cognito-identity get-credentials-for-identity --identity-id <identity_id> --no-sign`
    Or the following Script can be used.

```
import requests

region = "us-east-1"
id_pool_id = 'eu-west-1:098e5341-8364-038d-16de-1865e435da3b'
url = f'https://cognito-identity.{region}.amazonaws.com/'
headers = {"X-Amz-Target": "AWSCognitoIdentityService.GetId", "Content-Type": "application/x-amz-json-1.1"}
params = {'IdentityPoolId': id_pool_id}

r = requests.post(url, json=params, headers=headers)
json_resp = r.json()

if not "IdentityId" in json_resp:
    print(f"Not valid id: {id_pool_id}")
    exit

IdentityId = r.json()["IdentityId"]

params = {'IdentityId': IdentityId}

headers["X-Amz-Target"] = "AWSCognitoIdentityService.GetCredentialsForIdentity"
r = requests.post(url, json=params, headers=headers)

print(r.json())
```

The authenticated users may have more permissions than the unauthenticated users, so if you can signup inside the app, you can try to get new credentials.

### Authenticated

For this methodology it required have access to Identity Provider, it may be necessary to gain access to the identity provider. If the identity provider is a Cognito User Pool, it may be possible to exploit the default behavior and create a new user account.
For example, having access to Cognito User Pool, you can use the following commands

- `aws cognito-identity get-id --identity-pool-id <identity_pool_id> --logins cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID>=<ID_TOKEN>`
- `aws cognito-identity get-credentials-for-identity --identity-id <identity_id> --logins cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID>=<ID_TOKEN>`

It is possible to set up different IAM roles based on the identity provider a user is logging in through, or even based on specific user information (using claims). This means that if you have access to multiple users through different providers, it could be beneficial to log in and access the IAM roles for all of them.
